/* iso2usb.c generated by valac 0.26.1, the Vala compiler
 * generated from iso2usb.vala, do not modify */

/* using Gtk;*/
/* using GLib;*/
/* using Gee;*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gee.h>
#include <gio/gio.h>


#define TYPE_IMAGE (image_get_type ())
#define IMAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IMAGE, Image))
#define IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IMAGE, ImageClass))
#define IS_IMAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IMAGE))
#define IS_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IMAGE))
#define IMAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IMAGE, ImageClass))

typedef struct _Image Image;
typedef struct _ImageClass ImageClass;

#define TYPE_DEVICE (device_get_type ())
#define DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEVICE, Device))
#define DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEVICE, DeviceClass))
#define IS_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEVICE))
#define IS_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEVICE))
#define DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEVICE, DeviceClass))

typedef struct _Device Device;
typedef struct _DeviceClass DeviceClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _ImagePrivate ImagePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _DevicePrivate DevicePrivate;

#define TYPE_APP (app_get_type ())
#define APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APP, App))
#define APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APP, AppClass))
#define IS_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APP))
#define IS_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APP))
#define APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APP, AppClass))

typedef struct _App App;
typedef struct _AppClass AppClass;
typedef struct _AppPrivate AppPrivate;
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _Image {
	GObject parent_instance;
	ImagePrivate * priv;
	gchar* image;
	gchar* size;
};

struct _ImageClass {
	GObjectClass parent_class;
};

struct _Device {
	GObject parent_instance;
	DevicePrivate * priv;
	gchar* name;
	gchar* path;
};

struct _DeviceClass {
	GObjectClass parent_class;
};

struct _App {
	GObject parent_instance;
	AppPrivate * priv;
};

struct _AppClass {
	GObjectClass parent_class;
};

struct _AppPrivate {
	GtkWindow* window;
	GtkTreeView* treeview;
	GtkListStore* liststore;
	GtkListStore* deviceliststore;
	GtkButton* writebutton;
	GeeList* data;
};

struct _Block1Data {
	int _ref_count_;
	App* self;
	GVolumeMonitor* monitor;
};


extern Image* selectedImage;
Image* selectedImage = NULL;
extern Device* selectedDevice;
Device* selectedDevice = NULL;
static gpointer image_parent_class = NULL;
static gpointer device_parent_class = NULL;
static gpointer app_parent_class = NULL;

GType image_get_type (void) G_GNUC_CONST;
GType device_get_type (void) G_GNUC_CONST;
void on_button1_clicked (GtkButton* source);
void on_button2_clicked (GtkButton* source);
void on_treeview_selection4_changed (GtkTreeSelection* selection);
Image* image_new (const gchar* image, const gchar* size);
Image* image_construct (GType object_type, const gchar* image, const gchar* size);
void on_treeview_selection3_changed (GtkTreeSelection* selection);
Device* device_new (const gchar* name, const gchar* path);
Device* device_construct (GType object_type, const gchar* name, const gchar* path);
gint _vala_main (gchar** args, int args_length1);
GType app_get_type (void) G_GNUC_CONST;
App* app_new (void);
App* app_construct (GType object_type);
void app_start (App* self);
enum  {
	IMAGE_DUMMY_PROPERTY
};
gchar* image_get_pretty_size (Image* self);
gchar* image_to_string (Image* self);
static void image_finalize (GObject* obj);
enum  {
	DEVICE_DUMMY_PROPERTY
};
gchar* device_to_string (Device* self);
static void device_finalize (GObject* obj);
#define APP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_APP, AppPrivate))
enum  {
	APP_DUMMY_PROPERTY
};
void app_device_changed (App* self, GtkListStore* deviceliststore, GVolumeMonitor* monitor);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void app_find_images (App* self, GeeList* data);
static Image* app_get_selection (GtkTreeModel* model, GtkTreeIter* iter);
static void app_on_row_activated (App* self, GtkTreeView* treeview, GtkTreePath* path, GtkTreeViewColumn* column);
static void app_on_selection (App* self, GtkTreeSelection* selection);
static GObject * app_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void _app___lambda4_ (Block1Data* _data1_, GVolume* volume);
static void __app___lambda4__g_volume_monitor_volume_removed (GVolumeMonitor* _sender, GVolume* volume, gpointer self);
static void _app___lambda5_ (Block1Data* _data1_, GVolume* volume);
static void __app___lambda5__g_volume_monitor_volume_added (GVolumeMonitor* _sender, GVolume* volume, gpointer self);
static void _app_on_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self);
static void _app_on_selection_gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
static void _gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender, gpointer self);
static void app_finalize (GObject* obj);


void on_button1_clicked (GtkButton* source) {
	GtkButton* _tmp0_ = NULL;
	g_return_if_fail (source != NULL);
	_tmp0_ = source;
	gtk_button_set_label (_tmp0_, "Thank you!");
}


void on_button2_clicked (GtkButton* source) {
	GtkButton* _tmp0_ = NULL;
	g_return_if_fail (source != NULL);
	_tmp0_ = source;
	gtk_button_set_label (_tmp0_, "Thanks!");
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void on_treeview_selection4_changed (GtkTreeSelection* selection) {
	GtkTreeModel* model = NULL;
	GtkTreeIter iter = {0};
	gchar* image = NULL;
	gchar* size = NULL;
	GtkTreeSelection* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeIter _tmp2_ = {0};
	GtkTreeModel* _tmp3_ = NULL;
	GtkTreeIter _tmp4_ = {0};
	Image* _tmp5_ = NULL;
	FILE* _tmp6_ = NULL;
	Image* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	Image* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	g_return_if_fail (selection != NULL);
	_tmp0_ = selection;
	gtk_tree_selection_get_selected (_tmp0_, &_tmp1_, &_tmp2_);
	_g_object_unref0 (model);
	_tmp3_ = _g_object_ref0 (_tmp1_);
	model = _tmp3_;
	iter = _tmp2_;
	_tmp4_ = iter;
	gtk_tree_model_get (model, &_tmp4_, 0, &image, 1, &size, -1);
	_tmp5_ = image_new (image, size);
	_g_object_unref0 (selectedImage);
	selectedImage = _tmp5_;
	_tmp6_ = stderr;
	_tmp7_ = selectedImage;
	_tmp8_ = _tmp7_->image;
	_tmp9_ = selectedImage;
	_tmp10_ = _tmp9_->size;
	fprintf (_tmp6_, "Selected %s @ %s\n", _tmp8_, _tmp10_);
	_g_free0 (size);
	_g_free0 (image);
	_g_object_unref0 (model);
}


void on_treeview_selection3_changed (GtkTreeSelection* selection) {
	GtkTreeModel* model = NULL;
	GtkTreeIter iter = {0};
	gchar* name = NULL;
	gchar* path = NULL;
	GtkTreeSelection* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeIter _tmp2_ = {0};
	GtkTreeModel* _tmp3_ = NULL;
	GtkTreeIter _tmp4_ = {0};
	Device* _tmp5_ = NULL;
	FILE* _tmp6_ = NULL;
	Device* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	Device* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	g_return_if_fail (selection != NULL);
	_tmp0_ = selection;
	gtk_tree_selection_get_selected (_tmp0_, &_tmp1_, &_tmp2_);
	_g_object_unref0 (model);
	_tmp3_ = _g_object_ref0 (_tmp1_);
	model = _tmp3_;
	iter = _tmp2_;
	_tmp4_ = iter;
	gtk_tree_model_get (model, &_tmp4_, 0, &name, 1, &path, -1);
	_tmp5_ = device_new (name, path);
	_g_object_unref0 (selectedDevice);
	selectedDevice = _tmp5_;
	_tmp6_ = stderr;
	_tmp7_ = selectedDevice;
	_tmp8_ = _tmp7_->name;
	_tmp9_ = selectedDevice;
	_tmp10_ = _tmp9_->path;
	fprintf (_tmp6_, "Selected %s @ %s\n", _tmp8_, _tmp10_);
	_g_free0 (path);
	_g_free0 (name);
	_g_object_unref0 (model);
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	App* app = NULL;
	App* _tmp0_ = NULL;
	gtk_init (&args_length1, &args);
	_tmp0_ = app_new ();
	app = _tmp0_;
	app_start (app);
	gtk_main ();
	result = 0;
	_g_object_unref0 (app);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return _vala_main (argv, argc);
}


Image* image_construct (GType object_type, const gchar* image, const gchar* size) {
	Image * self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (image != NULL, NULL);
	g_return_val_if_fail (size != NULL, NULL);
	self = (Image*) g_object_new (object_type, NULL);
	_tmp0_ = image;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->image);
	self->image = _tmp1_;
	_tmp2_ = size;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->size);
	self->size = _tmp3_;
	return self;
}


Image* image_new (const gchar* image, const gchar* size) {
	return image_construct (TYPE_IMAGE, image, size);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


gchar* image_get_pretty_size (Image* self) {
	gchar* result = NULL;
	guint64 int_size = 0ULL;
	const gchar* _tmp0_ = NULL;
	gchar* pretty_size = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->size;
	int_size = (guint64) _tmp0_;
	_tmp1_ = g_format_size_full (int_size, G_FORMAT_SIZE_DEFAULT);
	pretty_size = _tmp1_;
	_tmp2_ = string_to_string (pretty_size);
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	_g_free0 (pretty_size);
	return result;
}


gchar* image_to_string (Image* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->image;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = self->size;
	_tmp3_ = string_to_string (_tmp2_);
	_tmp4_ = g_strconcat (_tmp1_, ", ", _tmp3_, NULL);
	result = _tmp4_;
	return result;
}


static void image_class_init (ImageClass * klass) {
	image_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = image_finalize;
}


static void image_instance_init (Image * self) {
}


static void image_finalize (GObject* obj) {
	Image * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_IMAGE, Image);
	_g_free0 (self->image);
	_g_free0 (self->size);
	G_OBJECT_CLASS (image_parent_class)->finalize (obj);
}


GType image_get_type (void) {
	static volatile gsize image_type_id__volatile = 0;
	if (g_once_init_enter (&image_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ImageClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) image_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Image), 0, (GInstanceInitFunc) image_instance_init, NULL };
		GType image_type_id;
		image_type_id = g_type_register_static (G_TYPE_OBJECT, "Image", &g_define_type_info, 0);
		g_once_init_leave (&image_type_id__volatile, image_type_id);
	}
	return image_type_id__volatile;
}


Device* device_construct (GType object_type, const gchar* name, const gchar* path) {
	Device * self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	self = (Device*) g_object_new (object_type, NULL);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->name);
	self->name = _tmp1_;
	_tmp2_ = path;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->path);
	self->path = _tmp3_;
	return self;
}


Device* device_new (const gchar* name, const gchar* path) {
	return device_construct (TYPE_DEVICE, name, path);
}


gchar* device_to_string (Device* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->name;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = self->path;
	_tmp3_ = string_to_string (_tmp2_);
	_tmp4_ = g_strconcat (_tmp1_, ", ", _tmp3_, NULL);
	result = _tmp4_;
	return result;
}


static void device_class_init (DeviceClass * klass) {
	device_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = device_finalize;
}


static void device_instance_init (Device * self) {
}


static void device_finalize (GObject* obj) {
	Device * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DEVICE, Device);
	_g_free0 (self->name);
	_g_free0 (self->path);
	G_OBJECT_CLASS (device_parent_class)->finalize (obj);
}


GType device_get_type (void) {
	static volatile gsize device_type_id__volatile = 0;
	if (g_once_init_enter (&device_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DeviceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) device_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Device), 0, (GInstanceInitFunc) device_instance_init, NULL };
		GType device_type_id;
		device_type_id = g_type_register_static (G_TYPE_OBJECT, "Device", &g_define_type_info, 0);
		g_once_init_leave (&device_type_id__volatile, device_type_id);
	}
	return device_type_id__volatile;
}


static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


void app_device_changed (App* self, GtkListStore* deviceliststore, GVolumeMonitor* monitor) {
	gboolean anydevices = FALSE;
	GList* volumes = NULL;
	GVolumeMonitor* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	FILE* _tmp19_ = NULL;
	gboolean _tmp20_ = FALSE;
	gchar* _tmp21_ = NULL;
	gchar* _tmp22_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (deviceliststore != NULL);
	g_return_if_fail (monitor != NULL);
	anydevices = FALSE;
	_tmp0_ = monitor;
	_tmp1_ = g_volume_monitor_get_volumes (_tmp0_);
	volumes = _tmp1_;
	_tmp2_ = volumes;
	{
		GList* volume_collection = NULL;
		GList* volume_it = NULL;
		volume_collection = _tmp2_;
		for (volume_it = volume_collection; volume_it != NULL; volume_it = volume_it->next) {
			GVolume* _tmp3_ = NULL;
			GVolume* volume = NULL;
			_tmp3_ = _g_object_ref0 ((GVolume*) volume_it->data);
			volume = _tmp3_;
			{
				gchar* volume_uuid = NULL;
				GVolume* _tmp4_ = NULL;
				gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				gchar* volume_label = NULL;
				GVolume* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				GtkTreeIter iter = {0};
				GtkListStore* _tmp9_ = NULL;
				GtkTreeIter _tmp10_ = {0};
				GtkListStore* _tmp11_ = NULL;
				GtkTreeIter _tmp12_ = {0};
				GVolume* _tmp13_ = NULL;
				GDrive* _tmp14_ = NULL;
				GDrive* _tmp15_ = NULL;
				gchar* _tmp16_ = NULL;
				gchar* _tmp17_ = NULL;
				const gchar* _tmp18_ = NULL;
				_tmp4_ = volume;
				_tmp5_ = g_volume_get_identifier (_tmp4_, G_VOLUME_IDENTIFIER_KIND_UUID);
				volume_uuid = _tmp5_;
				_tmp6_ = volume_uuid;
				if (_tmp6_ == NULL) {
					_g_free0 (volume_uuid);
					_g_object_unref0 (volume);
					continue;
				}
				anydevices = TRUE;
				_tmp7_ = volume;
				_tmp8_ = g_volume_get_identifier (_tmp7_, G_VOLUME_IDENTIFIER_KIND_LABEL);
				volume_label = _tmp8_;
				_tmp9_ = deviceliststore;
				gtk_list_store_append (_tmp9_, &_tmp10_);
				iter = _tmp10_;
				_tmp11_ = deviceliststore;
				_tmp12_ = iter;
				_tmp13_ = volume;
				_tmp14_ = g_volume_get_drive (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = g_drive_get_name (_tmp15_);
				_tmp17_ = _tmp16_;
				_tmp18_ = volume_label;
				gtk_list_store_set (_tmp11_, &_tmp12_, 0, _tmp17_, 1, _tmp18_, 2, "2", 3, "3", -1);
				_g_free0 (_tmp17_);
				_g_object_unref0 (_tmp15_);
				_g_free0 (volume_label);
				_g_free0 (volume_uuid);
				_g_object_unref0 (volume);
			}
		}
	}
	_tmp19_ = stderr;
	_tmp20_ = anydevices;
	_tmp21_ = bool_to_string (_tmp20_);
	_tmp22_ = _tmp21_;
	fprintf (_tmp19_, "anydevices: %s\n", _tmp22_);
	_g_free0 (_tmp22_);
	__g_list_free__g_object_unref0_0 (volumes);
}


void app_start (App* self) {
	GtkWindow* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->window;
	gtk_widget_show_all ((GtkWidget*) _tmp0_);
}


static void app_find_images (App* self, GeeList* data) {
	FILE* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (data != NULL);
	_tmp0_ = stderr;
	fprintf (_tmp0_, "in setup_imagelist\n");
	{
		gchar* home_dir = NULL;
		const gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gchar* download_dir = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		GFile* directory = NULL;
		const gchar* _tmp5_ = NULL;
		GFile* _tmp6_ = NULL;
		GFileEnumerator* enumerator = NULL;
		GFile* _tmp7_ = NULL;
		GFileEnumerator* _tmp8_ = NULL;
		gchar* file_name = NULL;
		gchar* _tmp9_ = NULL;
		GFileInfo* file_info = NULL;
		_tmp1_ = g_get_home_dir ();
		_tmp2_ = g_strdup (_tmp1_);
		home_dir = _tmp2_;
		_tmp3_ = home_dir;
		_tmp4_ = g_strconcat (_tmp3_, "/Downloads/", NULL);
		download_dir = _tmp4_;
		_tmp5_ = download_dir;
		_tmp6_ = g_file_new_for_path (_tmp5_);
		directory = _tmp6_;
		_tmp7_ = directory;
		_tmp8_ = g_file_enumerate_children (_tmp7_, "standard::*", 0, NULL, &_inner_error_);
		enumerator = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (directory);
			_g_free0 (download_dir);
			_g_free0 (home_dir);
			goto __catch0_g_error;
		}
		_tmp9_ = g_strdup ("");
		file_name = _tmp9_;
		while (TRUE) {
			GFileInfo* _tmp10_ = NULL;
			GFileEnumerator* _tmp11_ = NULL;
			GFileInfo* _tmp12_ = NULL;
			GFileInfo* _tmp13_ = NULL;
			GFileInfo* _tmp14_ = NULL;
			GFileInfo* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			gboolean file_name_ends_with_iso = FALSE;
			const gchar* _tmp18_ = NULL;
			gboolean _tmp19_ = FALSE;
			gboolean _tmp20_ = FALSE;
			gchar* file_size = NULL;
			GFileInfo* _tmp21_ = NULL;
			gint64 _tmp22_ = 0LL;
			gchar* _tmp23_ = NULL;
			Image* x = NULL;
			const gchar* _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			Image* _tmp26_ = NULL;
			GeeList* _tmp27_ = NULL;
			Image* _tmp28_ = NULL;
			FILE* _tmp29_ = NULL;
			const gchar* _tmp30_ = NULL;
			const gchar* _tmp31_ = NULL;
			_tmp11_ = enumerator;
			_tmp12_ = g_file_enumerator_next_file (_tmp11_, NULL, &_inner_error_);
			_tmp10_ = _tmp12_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file_info);
				_g_free0 (file_name);
				_g_object_unref0 (enumerator);
				_g_object_unref0 (directory);
				_g_free0 (download_dir);
				_g_free0 (home_dir);
				goto __catch0_g_error;
			}
			_tmp13_ = _tmp10_;
			_tmp10_ = NULL;
			_g_object_unref0 (file_info);
			file_info = _tmp13_;
			_tmp14_ = file_info;
			if (!(_tmp14_ != NULL)) {
				_g_object_unref0 (_tmp10_);
				break;
			}
			_tmp15_ = file_info;
			_tmp16_ = g_file_info_get_name (_tmp15_);
			_tmp17_ = g_strdup (_tmp16_);
			_g_free0 (file_name);
			file_name = _tmp17_;
			_tmp18_ = file_name;
			_tmp19_ = g_str_has_suffix (_tmp18_, ".iso");
			file_name_ends_with_iso = _tmp19_;
			_tmp20_ = file_name_ends_with_iso;
			if (_tmp20_ == FALSE) {
				_g_object_unref0 (_tmp10_);
				continue;
			}
			_tmp21_ = file_info;
			_tmp22_ = g_file_info_get_size (_tmp21_);
			_tmp23_ = g_strdup_printf ("%" G_GINT64_FORMAT, _tmp22_);
			file_size = _tmp23_;
			_tmp24_ = file_name;
			_tmp25_ = file_size;
			_tmp26_ = image_new (_tmp24_, _tmp25_);
			x = _tmp26_;
			_tmp27_ = self->priv->data;
			_tmp28_ = x;
			gee_collection_add ((GeeCollection*) _tmp27_, _tmp28_);
			_tmp29_ = stderr;
			_tmp30_ = file_name;
			_tmp31_ = file_size;
			fprintf (_tmp29_, "adding %s -- %s\n", _tmp30_, _tmp31_);
			_g_object_unref0 (x);
			_g_free0 (file_size);
			_g_object_unref0 (_tmp10_);
		}
		_g_object_unref0 (file_info);
		_g_free0 (file_name);
		_g_object_unref0 (enumerator);
		_g_object_unref0 (directory);
		_g_free0 (download_dir);
		_g_free0 (home_dir);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp32_ = NULL;
		GError* _tmp33_ = NULL;
		const gchar* _tmp34_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp32_ = stderr;
		_tmp33_ = e;
		_tmp34_ = _tmp33_->message;
		fprintf (_tmp32_, "Error: %s\n", _tmp34_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static Image* app_get_selection (GtkTreeModel* model, GtkTreeIter* iter) {
	Image* result = NULL;
	Image* p = NULL;
	Image* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeIter _tmp2_ = {0};
	g_return_val_if_fail (model != NULL, NULL);
	g_return_val_if_fail (iter != NULL, NULL);
	_tmp0_ = image_new ("new", "0");
	p = _tmp0_;
	_tmp1_ = model;
	_tmp2_ = *iter;
	gtk_tree_model_get (_tmp1_, &_tmp2_, 0, &p->image, 1, &p->size, -1);
	result = p;
	return result;
}


static void app_on_row_activated (App* self, GtkTreeView* treeview, GtkTreePath* path, GtkTreeViewColumn* column) {
	GtkTreeIter iter = {0};
	GtkTreeView* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeModel* _tmp2_ = NULL;
	GtkTreePath* _tmp3_ = NULL;
	GtkTreeIter _tmp4_ = {0};
	gboolean _tmp5_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (treeview != NULL);
	g_return_if_fail (path != NULL);
	g_return_if_fail (column != NULL);
	_tmp0_ = treeview;
	_tmp1_ = gtk_tree_view_get_model (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = path;
	_tmp5_ = gtk_tree_model_get_iter (_tmp2_, &_tmp4_, _tmp3_);
	iter = _tmp4_;
	if (_tmp5_) {
		Image* p = NULL;
		GtkTreeView* _tmp6_ = NULL;
		GtkTreeModel* _tmp7_ = NULL;
		GtkTreeModel* _tmp8_ = NULL;
		GtkTreeIter _tmp9_ = {0};
		Image* _tmp10_ = NULL;
		FILE* _tmp11_ = NULL;
		Image* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		_tmp6_ = treeview;
		_tmp7_ = gtk_tree_view_get_model (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = iter;
		_tmp10_ = app_get_selection (_tmp8_, &_tmp9_);
		p = _tmp10_;
		_tmp11_ = stderr;
		_tmp12_ = p;
		_tmp13_ = image_to_string (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_strconcat ("Clicked ", _tmp14_, NULL);
		_tmp16_ = _tmp15_;
		fprintf (_tmp11_, "%s", _tmp16_);
		_g_free0 (_tmp16_);
		_g_free0 (_tmp14_);
		_g_object_unref0 (p);
	}
}


static void app_on_selection (App* self, GtkTreeSelection* selection) {
	GtkTreeModel* model = NULL;
	GtkTreeIter iter = {0};
	GtkTreeSelection* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeIter _tmp2_ = {0};
	gboolean _tmp3_ = FALSE;
	GtkTreeModel* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (selection != NULL);
	_tmp0_ = selection;
	_tmp3_ = gtk_tree_selection_get_selected (_tmp0_, &_tmp1_, &_tmp2_);
	_g_object_unref0 (model);
	_tmp4_ = _g_object_ref0 (_tmp1_);
	model = _tmp4_;
	iter = _tmp2_;
	if (_tmp3_) {
		Image* p = NULL;
		GtkTreeModel* _tmp5_ = NULL;
		GtkTreeIter _tmp6_ = {0};
		Image* _tmp7_ = NULL;
		FILE* _tmp8_ = NULL;
		Image* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		_tmp5_ = model;
		_tmp6_ = iter;
		_tmp7_ = app_get_selection (_tmp5_, &_tmp6_);
		p = _tmp7_;
		_tmp8_ = stderr;
		_tmp9_ = p;
		_tmp10_ = image_to_string (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat ("Selected ", _tmp11_, NULL);
		_tmp13_ = _tmp12_;
		fprintf (_tmp8_, "%s", _tmp13_);
		_g_free0 (_tmp13_);
		_g_free0 (_tmp11_);
		_g_object_unref0 (p);
	}
	_g_object_unref0 (model);
}


App* app_construct (GType object_type) {
	App * self = NULL;
	self = (App*) g_object_new (object_type, NULL);
	return self;
}


App* app_new (void) {
	return app_construct (TYPE_APP);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		App* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->monitor);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void _app___lambda4_ (Block1Data* _data1_, GVolume* volume) {
	App* self;
	GtkListStore* _tmp0_ = NULL;
	GtkListStore* _tmp1_ = NULL;
	GVolumeMonitor* _tmp2_ = NULL;
	self = _data1_->self;
	g_return_if_fail (volume != NULL);
	_tmp0_ = self->priv->deviceliststore;
	gtk_list_store_clear (_tmp0_);
	_tmp1_ = self->priv->deviceliststore;
	_tmp2_ = _data1_->monitor;
	app_device_changed (self, _tmp1_, _tmp2_);
}


static void __app___lambda4__g_volume_monitor_volume_removed (GVolumeMonitor* _sender, GVolume* volume, gpointer self) {
	_app___lambda4_ (self, volume);
}


static void _app___lambda5_ (Block1Data* _data1_, GVolume* volume) {
	App* self;
	GtkListStore* _tmp0_ = NULL;
	GtkListStore* _tmp1_ = NULL;
	GVolumeMonitor* _tmp2_ = NULL;
	self = _data1_->self;
	g_return_if_fail (volume != NULL);
	_tmp0_ = self->priv->deviceliststore;
	gtk_list_store_clear (_tmp0_);
	_tmp1_ = self->priv->deviceliststore;
	_tmp2_ = _data1_->monitor;
	app_device_changed (self, _tmp1_, _tmp2_);
}


static void __app___lambda5__g_volume_monitor_volume_added (GVolumeMonitor* _sender, GVolume* volume, gpointer self) {
	_app___lambda5_ (self, volume);
}


static void _app_on_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self) {
	app_on_row_activated ((App*) self, _sender, path, column);
}


static void _app_on_selection_gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	app_on_selection ((App*) self, _sender);
}


static void _gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	gtk_main_quit ();
}


static GObject * app_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	App * self;
	Block1Data* _data1_;
	GtkBuilder* builder = NULL;
	GtkBuilder* _tmp0_ = NULL;
	GtkBuilder* _tmp8_ = NULL;
	GtkBuilder* _tmp9_ = NULL;
	GObject* _tmp10_ = NULL;
	GtkWindow* _tmp11_ = NULL;
	GtkBuilder* _tmp12_ = NULL;
	GObject* _tmp13_ = NULL;
	GtkTreeView* _tmp14_ = NULL;
	GtkBuilder* _tmp15_ = NULL;
	GObject* _tmp16_ = NULL;
	GtkListStore* _tmp17_ = NULL;
	GtkBuilder* _tmp18_ = NULL;
	GObject* _tmp19_ = NULL;
	GtkButton* _tmp20_ = NULL;
	GtkListStore* _tmp21_ = NULL;
	GeeList* _tmp22_ = NULL;
	GtkBuilder* _tmp46_ = NULL;
	GObject* _tmp47_ = NULL;
	GtkListStore* _tmp48_ = NULL;
	GtkListStore* _tmp49_ = NULL;
	GVolumeMonitor* _tmp50_ = NULL;
	GtkListStore* _tmp51_ = NULL;
	GVolumeMonitor* _tmp52_ = NULL;
	GVolumeMonitor* _tmp53_ = NULL;
	GVolumeMonitor* _tmp54_ = NULL;
	GtkTreeView* _tmp55_ = NULL;
	GtkTreeView* _tmp56_ = NULL;
	GtkTreeSelection* _tmp57_ = NULL;
	GtkWindow* _tmp58_ = NULL;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (app_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_APP, App);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = gtk_builder_new ();
	builder = _tmp0_;
	{
		GtkBuilder* _tmp1_ = NULL;
		_tmp1_ = builder;
		gtk_builder_add_from_file (_tmp1_, "iso2usb.ui", &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		FILE* _tmp2_ = NULL;
		GError* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = stderr;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		_tmp5_ = string_to_string (_tmp4_);
		_tmp6_ = g_strconcat (_tmp5_, "\n", NULL);
		_tmp7_ = _tmp6_;
		fprintf (_tmp2_, "%s", _tmp7_);
		_g_free0 (_tmp7_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (builder);
		block1_data_unref (_data1_);
		_data1_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_tmp8_ = builder;
	gtk_builder_connect_signals (_tmp8_, self);
	_tmp9_ = builder;
	_tmp10_ = gtk_builder_get_object (_tmp9_, "window");
	_tmp11_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp10_, gtk_window_get_type ()) ? ((GtkWindow*) _tmp10_) : NULL);
	_g_object_unref0 (self->priv->window);
	self->priv->window = _tmp11_;
	_tmp12_ = builder;
	_tmp13_ = gtk_builder_get_object (_tmp12_, "treeview");
	_tmp14_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp13_, gtk_tree_view_get_type ()) ? ((GtkTreeView*) _tmp13_) : NULL);
	_g_object_unref0 (self->priv->treeview);
	self->priv->treeview = _tmp14_;
	_tmp15_ = builder;
	_tmp16_ = gtk_builder_get_object (_tmp15_, "ImageListStore");
	_tmp17_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp16_, gtk_list_store_get_type ()) ? ((GtkListStore*) _tmp16_) : NULL);
	_g_object_unref0 (self->priv->liststore);
	self->priv->liststore = _tmp17_;
	_tmp18_ = builder;
	_tmp19_ = gtk_builder_get_object (_tmp18_, "WriteToDriveButton");
	_tmp20_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp19_, gtk_button_get_type ()) ? ((GtkButton*) _tmp19_) : NULL);
	_g_object_unref0 (self->priv->writebutton);
	self->priv->writebutton = _tmp20_;
	_tmp21_ = self->priv->liststore;
	gtk_list_store_clear (_tmp21_);
	_tmp22_ = self->priv->data;
	app_find_images (self, _tmp22_);
	{
		GeeList* _p_list = NULL;
		GeeList* _tmp23_ = NULL;
		GeeList* _tmp24_ = NULL;
		gint _p_size = 0;
		GeeList* _tmp25_ = NULL;
		gint _tmp26_ = 0;
		gint _tmp27_ = 0;
		gint _p_index = 0;
		_tmp23_ = self->priv->data;
		_tmp24_ = _g_object_ref0 (_tmp23_);
		_p_list = _tmp24_;
		_tmp25_ = _p_list;
		_tmp26_ = gee_collection_get_size ((GeeCollection*) _tmp25_);
		_tmp27_ = _tmp26_;
		_p_size = _tmp27_;
		_p_index = -1;
		while (TRUE) {
			gint _tmp28_ = 0;
			gint _tmp29_ = 0;
			gint _tmp30_ = 0;
			Image* p = NULL;
			GeeList* _tmp31_ = NULL;
			gint _tmp32_ = 0;
			gpointer _tmp33_ = NULL;
			GtkTreeIter iter = {0};
			Image* _tmp34_ = NULL;
			gchar* _tmp35_ = NULL;
			gchar* _tmp36_ = NULL;
			GtkListStore* _tmp37_ = NULL;
			GtkTreeIter _tmp38_ = {0};
			GtkListStore* _tmp39_ = NULL;
			GtkTreeIter _tmp40_ = {0};
			Image* _tmp41_ = NULL;
			const gchar* _tmp42_ = NULL;
			Image* _tmp43_ = NULL;
			gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			_tmp28_ = _p_index;
			_p_index = _tmp28_ + 1;
			_tmp29_ = _p_index;
			_tmp30_ = _p_size;
			if (!(_tmp29_ < _tmp30_)) {
				break;
			}
			_tmp31_ = _p_list;
			_tmp32_ = _p_index;
			_tmp33_ = gee_list_get (_tmp31_, _tmp32_);
			p = (Image*) _tmp33_;
			_tmp34_ = p;
			_tmp35_ = image_to_string (_tmp34_);
			_tmp36_ = _tmp35_;
			_g_free0 (_tmp36_);
			_tmp37_ = self->priv->liststore;
			gtk_list_store_append (_tmp37_, &_tmp38_);
			iter = _tmp38_;
			_tmp39_ = self->priv->liststore;
			_tmp40_ = iter;
			_tmp41_ = p;
			_tmp42_ = _tmp41_->image;
			_tmp43_ = p;
			_tmp44_ = image_get_pretty_size (_tmp43_);
			_tmp45_ = _tmp44_;
			gtk_list_store_set (_tmp39_, &_tmp40_, 0, _tmp42_, 1, _tmp45_, -1);
			_g_free0 (_tmp45_);
			_g_object_unref0 (p);
		}
		_g_object_unref0 (_p_list);
	}
	_tmp46_ = builder;
	_tmp47_ = gtk_builder_get_object (_tmp46_, "DeviceListStore");
	_tmp48_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp47_, gtk_list_store_get_type ()) ? ((GtkListStore*) _tmp47_) : NULL);
	_g_object_unref0 (self->priv->deviceliststore);
	self->priv->deviceliststore = _tmp48_;
	_tmp49_ = self->priv->deviceliststore;
	gtk_list_store_clear (_tmp49_);
	_tmp50_ = g_volume_monitor_get ();
	_data1_->monitor = _tmp50_;
	_tmp51_ = self->priv->deviceliststore;
	_tmp52_ = _data1_->monitor;
	app_device_changed (self, _tmp51_, _tmp52_);
	_tmp53_ = _data1_->monitor;
	g_signal_connect_data (_tmp53_, "volume-removed", (GCallback) __app___lambda4__g_volume_monitor_volume_removed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp54_ = _data1_->monitor;
	g_signal_connect_data (_tmp54_, "volume-added", (GCallback) __app___lambda5__g_volume_monitor_volume_added, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp55_ = self->priv->treeview;
	g_signal_connect_object (_tmp55_, "row-activated", (GCallback) _app_on_row_activated_gtk_tree_view_row_activated, self, 0);
	_tmp56_ = self->priv->treeview;
	_tmp57_ = gtk_tree_view_get_selection (_tmp56_);
	g_signal_connect_object (_tmp57_, "changed", (GCallback) _app_on_selection_gtk_tree_selection_changed, self, 0);
	_tmp58_ = self->priv->window;
	g_signal_connect ((GtkWidget*) _tmp58_, "destroy", (GCallback) _gtk_main_quit_gtk_widget_destroy, NULL);
	_g_object_unref0 (builder);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return obj;
}


static void app_class_init (AppClass * klass) {
	app_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AppPrivate));
	G_OBJECT_CLASS (klass)->constructor = app_constructor;
	G_OBJECT_CLASS (klass)->finalize = app_finalize;
}


static void app_instance_init (App * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = APP_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (TYPE_IMAGE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->priv->data = (GeeList*) _tmp0_;
}


static void app_finalize (GObject* obj) {
	App * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_APP, App);
	_g_object_unref0 (self->priv->window);
	_g_object_unref0 (self->priv->treeview);
	_g_object_unref0 (self->priv->liststore);
	_g_object_unref0 (self->priv->deviceliststore);
	_g_object_unref0 (self->priv->writebutton);
	_g_object_unref0 (self->priv->data);
	G_OBJECT_CLASS (app_parent_class)->finalize (obj);
}


GType app_get_type (void) {
	static volatile gsize app_type_id__volatile = 0;
	if (g_once_init_enter (&app_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AppClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) app_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (App), 0, (GInstanceInitFunc) app_instance_init, NULL };
		GType app_type_id;
		app_type_id = g_type_register_static (G_TYPE_OBJECT, "App", &g_define_type_info, 0);
		g_once_init_leave (&app_type_id__volatile, app_type_id);
	}
	return app_type_id__volatile;
}



